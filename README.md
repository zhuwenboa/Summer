## Summer网络库
- Summer是一个非阻塞IO+reactor模型的网络库。
- 采用的是One loop per thread(每个IO线程一个epoll/eventloop) 模型。
- 用C++11编写。具有C++11的新特性： 智能指针，lambda表达式等


### 项目的技术
##### 1 项目的难点
- 在实现one loop per thread模型，如何更好的减少线程之间的竞争关系，减少锁的争用是一个难点，当竞争关系越少，我们的服务器效率会更快。
- 让线程之间的模块划分，回调函数等也是一个值得思考的点。
- 采用RAII，来确保对象资源的正确释放，不会导致有未释放的对象占用系统资源。
- 用无锁队列来存储其它线程的回调函数 
- 客户连接在服务器中的释放顺序。

##### Mysql连接池
- 事先将mysql连接进行创建进行池化，提供给客户进行使用。可以减少用户在使用期间进行创建的开销。
- Mysql连接池有接口提供给客户进行使用，用互斥锁保证线程安全。

##### Buffer设计
1. 普通读写buffer: 采用std::vector<char>作为底层实现，用读写下标来进行操作。当数据溢出时，进行扩容，并移动数据后进行填充。

2. 环形buffer: 适用于通信双方发送消息都是定长，因为这样子我们可以预先设计好buffer的长度，不常扩容，环形buffer在性能上就会有很大的优势体现。
- 可以根据客户的业务进行抉择。

##### 无锁队列(CAS编程思想)
- 用gcc支持的 bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)函数实现的无锁队列。 

- 优点：没有锁的争用，不会让线程挂起等待阻塞住。不会让操作系统进行调度，效率提升。
- 缺点：首先就是如果一直拿不到最新的数据，while会一直循环运行，会使得线程相当于空转，浪费CPU资源。

##### 定时器设计
- 采用红黑树作为底层的std::multiset当作容器存储。
- 用Id来将到期时间相同的Timer类进行区分。
- 用Linux下的timerfd进行唤醒。

##### 心跳机制
1. 服务端设置KeepAlive。
2. 客户端会定时给服务端发送心跳包，当服务端收到后，会将其定时器重新设置。如果在设定时间内没有收到客户端的心跳包或者没有任何客户数据到达，那服务端就认为客户端异常关闭然后将其连接进行关闭。

##### 日志类
1. 前后端分离的日志类，用户日志向writeBuf中写入，等写入到指定长度后，将其交换到flushBuf中，然后再向文件刷新。可以减少对文件的写入，提升效率。
2. 会定期进行刷新，在指定时间内到期会进行刷新。
3. 会动态创建日志文件进行存储日志信息。

##### 连接器 Connector类
1. 采用非阻塞connect调用方式发起主动连接。
2. 如果连接失败则进行连接重试。(加入到定时器中按照设置时间到时后进行重连)
https://blog.csdn.net/weixin_42250655/article/details/102782401 关于非阻塞connect的博客

##### 测试用例
1. [Echo演示结果](https://github.com/zhuwenboa/Summer/tree/master/test/Echo)

